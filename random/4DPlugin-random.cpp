/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-random.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : random
 #	author : miyako
 #	2020/04/16
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-random.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- random
            
			case 1 :
				generate_random_number(params);
				break;
			case 2 :
				generate_random_bytes(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

typedef enum {
   
    generate_random_algorithm_default = 0
    
} generate_random_algorithm_t;

static BOOL generate_random(std::vector<unsigned char> &buf,
                            size_t size,
                            generate_random_algorithm_t mode = generate_random_algorithm_default) {
    
    if(size > 0) {
        buf.resize(size);
        
        switch (mode) {

            case generate_random_algorithm_default:
            default:

#if VERSIONMAC
                if(errSecSuccess == SecRandomCopyBytes(kSecRandomDefault, size, &buf[0])) {
                    return TRUE;
                }
#else
                BCRYPT_ALG_HANDLE h = NULL;

                if (BCRYPT_SUCCESS(
                                    BCryptOpenAlgorithmProvider(&h,
                                                                BCRYPT_RNG_ALGORITHM,
                                                                MS_PRIMITIVE_PROVIDER,
                                                                0))) {
                    BOOL success = BCRYPT_SUCCESS(BCryptGenRandom(h,
                                                                  (PUCHAR) &buf[0],
                                                                  size,
                                                                  0));
                    BCryptCloseAlgorithmProvider(h, 0);
                    
                    return success;
                }
#endif
                break;
        }
        
        
    }
    
    return FALSE;
}

void generate_random_number(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();
    
    size_t size = sizeof(PA_long32);
    
    std::vector<unsigned char>buf(size);
    
    if(generate_random(buf, size)) {
        
        PA_long32 returnValue = 0;
        
        memcpy(&returnValue, &buf[0], sizeof(PA_long32));
               
        ob_set_b(status, L"success", true);
        ob_set_n(status, L"value", returnValue);
        
    }else {
        
        ob_set_b(status, L"success", false);
        
    }
    
    PA_ReturnObject(params, status);
}

void generate_random_bytes(PA_PluginParameters params) {

    PA_ObjectRef options = PA_GetObjectParameter(params, 1);
    
    size_t size = sizeof(PA_long32);
    
    if(options) {
        if(ob_is_defined(options, L"size")) {
            size = static_cast<size_t>(ob_get_n(options, L"size"));
        }
    }
    
    std::vector<unsigned char>buf(0);
    
    if(generate_random(buf, size)) {
        PA_ReturnBlob(params, buf.data(), (PA_long32)buf.size());
    }else {
        PA_ReturnBlob(params, (void *)"", 0);
    }

}
